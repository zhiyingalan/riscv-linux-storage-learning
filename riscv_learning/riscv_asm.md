

# 整数运算

## addi

**addi rd, rs1, imm**

将有符号立即数imm和寄存器rs1中的值相加，结果写入rd寄存器。

rd = rs1 + imm

其中：

imm为12bit，取值范围为[-2047, 2048]

rs1/rd为5bit，对应x0~x31共32个寄存器

## add

**add rd, rs1, rs2**

将有符号寄存器rs2和寄存器rs1中的值相加，结果写入rd寄存器

rd = rs1 + rs2

其中：

rs1/rs2/rd为5bit，对应x0~x31共32个寄存器

## sub

**sub rd, rs1, rs2**

寄存器rs1减去寄存器rs2得到结果写入rd寄存器

rd = rs1 - rs2

## andi

**andi rd, rs1, imm**

将rs1和有符号imm求逻辑与，结果写入rd

rd = rs1 & imm

其中：

imm为12bit，取值范围为[-2047, 2048]

# 加载数据

## lui

**lui rd, imm**

将imm左移20位后赋值给rd，低12位补0

rd = imm << 12

## auipc

**auipc rd, imm**

将立即数高 20 位加到程序计数器

rd = PC + (imm << 12)

* 参数介绍：

​	`PC`:当前`auipc`的内存地址

​	`imm << 12`:将立即数左移12位

* 特性

​	基于 PC 计算地址，天生支持**位置无关代码（PIC）**（程序加载到任意地址都能正确计算符号偏移），这是动态链接的核心要求。

`auipc`**极少单独使用**，因为仅能计算地址的高 32 位，实际开发中几乎都是**与 12 位立即数的指令配合**，形成**地址拼接组合拳**，核心应用场景有 2 个：

**场景 1：配合`ld/lw`（加载指令）→ 访问全局数据符号（如你的代码）**

动态链接中访问全局数据（如`msg`字符串），通过`auipc + ld`组合实现，是你这份反汇编的核心应用，规则：
```
auipc rd, imm20  # 计算高20位地址，存入rd
ld rd, imm12(rd) # 用12位立即数imm12补充低12位，最终rd=完整地址
```
- `imm12`：12 位**有符号立即数**（取值`-2048 ~ +2047`），可正向 / 反向偏移，适配地址的低 12 位调整。

**场景 2：配合`jalr/addi`（跳转 / 加法指令）→ 调用全局函数 / 访问代码符号**

访问全局函数（如动态链接的库函数），通过`auipc + jalr`组合实现，规则：
```
auipc rd, imm20   # 计算高20位地址，存入rd
jalr rd, imm12(rd)# 跳转到拼接后的完整地址，实现函数调用
```

# 环境调用

## ecall

```assembly
00000000000002b8 <_start>:
 2b8:	4505                li	a0,1        # 系统调用参数1：文件描述符fd=1（标准输出stdout，屏幕）
 2ba:	00002597          	auipc	a1,0x2  # 配合下一条指令，将a1指向GOT表0x2028（运行时填充msg真实地址0x2000）
 2be:	d6e5b583          	ld	a1,-658(a1) # 系统调用参数2：缓冲区地址buf=msg的真实地址（0x2000，.data段字符串）
 2c2:	463d                li	a2,15       # 系统调用参数3：写入长度count=15（Hello RISC-V!\n\0共15字节）
 2c4:	04000893          	li	a7,64       # 系统调用号：64（Linux RISC-V 64的write系统调用固定为64）
 2c8:	00000073          	ecall           # 触发系统调用，执行内核的write功能
```

**ecall 的具体执行流程（用户态→内核态）**

1. **触发陷阱**：执行`ecall`后，RISC-V 硬件触发**环境陷阱**，暂停用户程序执行，将程序计数器 PC 指向内核的**陷阱处理入口**；

2. **特权级切换**：从**用户态（U-mode）\**切换到\**内核态（S-mode/Supervisor）**，内核获得最高执行权限，可访问硬件资源（显示器、文件系统）；

3. **内核解析调用**：内核从`a7`寄存器读取到系统调用号`64`，匹配到`sys_write`内核函数；

4. 内核执行 write

   内核根据a0-a2的参数，执行标准输出写入：

   - 从`a1=0x2000`（.data 段）读取 15 字节`(a2=15)` 的字符串`Hello RISC-V!\n\0`；
   - 将数据写入`a0=1`对应的标准输出设备（屏幕 / 终端）；
   
5. **切回用户态**：write 执行完成后，内核清理现场，从内核态切回用户态，继续执行 ecall 的下一条指令。

**关键关联：动态链接下的参数 2（buf 地址）**

动态链接下，`a1`并非直接指向`msg`的`0x2000`，而是先指向 GOT 表`0x2028`，**ecall 执行前，动态链接器已将 GOT 表 0x2028 填充为 msg 的真实地址 0x2000**，所以内核最终读取的是正确的字符串地址。



# 伪指令

## li

li a0, constant

**l**oad **i**mm

加载立即数constant到a0

**`li`指令后面的constant必须为数字，且翻译规则为**

**小数值（-2048 ~ +2047，12 位立即数范围）**：直接翻译为 `addi` 指令（利用 `zero` 寄存器永远为 0 的特性）；

例：你代码中的 `li a0, 1` → 翻译为 `addi a0, zero, 1`（机器码 `4505`）；

例：`li a7, 64` → 翻译为 `addi a7, zero, 64`（机器码 `04000893`）；

**大数值（超出 12 位范围，如 0x12345678）**：翻译为 `auipc + addi` 组合（拼接 32 位数值）；

例：`li a0, 0x12345678` → `auipc a0, 0x12345` + `addi a0, a0, 0x678`。

**翻译规则：小数值→addi；大数值→auipc+addi**

**典型用途：赋系统调用号、参数值、退出码等数值**

## la

la a0, addr

加载符号地址addr到a0

**l**oad **a**ddr

**`la`指令后面的addr最好为符号**

```assembly
la a1, msg      # 给a1赋“字符串msg的内存地址”（不是数值，是地址）
```

**翻译规则：永远→auipc+addi（32 位）/auipc+ld（64 位）**

**典型用途：取字符串、函数、全局变量的内存地址**
